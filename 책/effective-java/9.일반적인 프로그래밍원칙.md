> 아이템57. 지역변수의 범위를 최소화 하라.

- 아이템 15 클래스와 멤버의 접근권한을 최소화하라랑 취지가 비슷하다.
- 지역변수를 효율적으로 최소화하는 방법
    + 1.지역변수의 범위를 줄이는 가장 강력한 기법은 '가장 처음 쓰일 때 선언하기'
    + 2. 모든 지역 변수는 선언과 동시에 초기화 한다.
        - while 문보다는 for문을 쓸것 (가독성과 잘못 쓸 경우의 에러 확률을 낮춘다.)
    + 3. 메소드를 작게 유지하고 한 가지 기능에 집중하는 것
        - 순수함수로 작성하고, 메소드에서 너무 많은 일을 하지 말 것
        
> 아이템58. 전통적인 for 문보다는 for-each 문을 사용해라.
- 좋지 않은 방법 : 컬렉션을 순회하는 코드
```java
for(Iterator<Element> i = c.iterator(); i.hasNext();){
    ...
}
```
- 올바른 관용구
```java
for (Element e: elements) {
}
```

- forEach 문을 사용할 수 없는 상황
    + 파괴적인 필터링 : 컬렉션을 순회하며 원소를 제거해야 한다면, iterator의 remove 메소드를 이용해야 한다.
        - foreach 문장을 사용하여 리스트 자체를 수정하게 되는 경우에는 ConcurrentModificationException이 발생함.
        - 기본적으로 리스트는 순회중 자기 자신에 대한 삭제와 같은 변경을 허용하지 않음.
    + 변형 : 배열이나 리스트의 원소를 바꾸고 싶다면, 인덱스를 사용해야 한다.
    + 병렬 반복 : 한 중첩문에 여러 컬렉션에 병렬로 순회해야 한다면, 인덱스 변수를 사용해 엄격하고 명시적으로 제어 해야 한다.

- **forEach 문은 컬렉션과 배열은 물론 iterable 인터페이스를 구현한 객체면 무엇이든 순회할 수 있다.**

> 아이템 59. 라이브러리를 익히고 사용하자.

- 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 우리보다 앞서 사용한 다른 사용자의 경험을 활용할 수 있다.
- 라이브러리의 새로운 버전이 릴리즈 되었다면, 이로운 수많은 기능이 추가되었을 것임에 활용하자.  
    + ex) 자바 7 부터는 Random 클래스 대신 ThreadLocalRandom 클래스를 사용하면 더 많은 기능과 더 나은 성능향상을 맛볼 수있다.
    + 새로운 버전의 라이브러리를 사용할 때 문제가 생길 경우, 버전이 stable 한지 체크해봐야 한다.(개인 의견)
    
- 따로 노력하지 않아도 라이브러리를 쓰면 지속적으로 기능 개선이 이루어진다.
- 자바 프로그래머라면 적어도 java.lang, java.util. java.io 패키지 하위 클래스는 익숙해지면 좋다.

- 또다른 예로, 새로운 라이브러리의 사용 도입을 고려할 경우 관리가 꾸준히 될 수 있는 라이브러리(ex: hystrix -> resilience4j)를 고려해보자.

> 아이템60. 정확한 답이 필요하면 float과 double은 피하라.
- float과 double 타입은 금융관련 계산과 맞지 않는다.
- int, long을 우선하여 사용하고 더 정확하게 사용하려면 BigDecimal, BigInteger 등을 사용하자
- BigDecimal.. 의 객체를 쓰면 성능이 느릴 수 있음에 주의하자.

> 아이템61. 박싱된 기본 타입보다는 기본 타입을 사용하라.
- 기본 타입 : int, double, boolean
- 박싱 타입 : Double, Boolean

- 기본 타입(Primitive Type)
- 스택 영역에 저장되기 때문에, 메모리 효율성과 접근면에서 뛰어나다.

- 박싱된 기본 타입(boxed Primitives Type)
    + collection에서 사용할 떄는 Primitive type을 사용할 수 없으므로 boxed primitive type을 사용해야한다.
    + 명시적으로 null을 주입해야 할 경우
       + db에 명시적으로 null을 넣고자 할 때 int(primitive type)를 사용하면 기본 값(0)이 적용된다. 
    + parameterized type을 사용할 때
       + List<Long>
    + boxed primitives는 Wrapping Object이므로, 비교연산(==)에 주의하자.
    
- 자바에서 오토박싱을 지원하지만 (primitive -> boxed primitive), 위험성을 줄이지 않으므로 주의하자.

> 아이템62. 다른 타입이 적절하다면 문자열 사용을 피하라.
- 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
- 열거 타입을 대신하기 적합하지 않다. (아이템 34)

- 혼합 타입의 부적절한 예 : 문자열을 파싱해야 해서 느리고, equals toString을 제공못하고.. 등이 있다.
```
String compoundKey = className + "#" + i.next();
```
- String 간의 연산은 괜찮다고 생각한다.
```java
String suffix = ".";
String compoundKey = className + "#" + suffix; 
```

> 아이템 63. 문자열 연결은 느리니 주의하라.
- 문자열 연결 연산자로 문자열 n개를 잇는 시간은 n 제곱 시간에 비례한다.
    + 문자열은 불변이고, String 객체이기에 객체간의 연결은 새로운 객체를 만들어낸다.
- 성능을 포기하고 싶지 않다면, Sting 대신 StringBuilder를 사용하자.
-간단한 String의 연산이라면 (item62의 예) + 사용하는게 가독성을 위해 나을 수도 있겠다.

> 아이템 64. 객체는 인터페이스를 사용해 참조해라

- 적합한 인터페이스만 있다면 매개변수 뿐만 아니라 반환값, 변수 필드를 전부 인터페이스 타입으로 선언하라.
    + 인터페이스를 타입으로 사용하는 습관은 프로그램이 훨씬 유연하게 만들어지게 도와줄 것이다.
- 적합한 인터페이스가 없다면 가장 추상적으로 표현할 수 있는 클래스 타입으로 사용하라.

> 아이템 65. 리플렉션보다는 인터페이스를 사용해라.

- 리플렉션의 단점
    + 컴파일 타임 시 타입검사가 주는 이점을 하나도 누릴 수 없다.
    + 리플렉션을 이용하면 코드의 가독성이 떨어진다.
    + 성능이 떨어진다.
- 참고: https://docs.oracle.com/javase/tutorial/reflect/index.html

- 리플렉션의 예) spring DI, metric system(scouter..)
- 리플렉션에 대한 오해: 
- 리플렉션은 복잡한 특수 시스템을 개발할 때 필요한 강력한 기능이지만 단점도 많다.

> 아이템 66. 네이티브 메소드는 신중히 사용해라.
- 성능 개선을 목적으로 네이티브 메소드를사용하는 것은 권장하지 않는다.
- low-level 라이브러리에서 사용해야만 하는 경우 어쩔 수없이 쓴다.
- 쓰는 예) io.netty.channel.epoll.Native 
    + epoll은 리눅스에서 select의 단점을 보완하여 사용할 수 있도록 만든 I/O통지 모델
```
epoll
파일 디스크립터를 사용자가 아닌 커널이 관리한다.
그만큼 CPU는 계속해서 파일 디스크립터의 상태 변화를 감시할 필요가 없다. 
- 체크
소켓이 열리면 시스템 어느 파일 디스크립트에 쓰여진다.
select 모델은 어느 파일 디스크립터가 이벤트가 발생했는지 FD_ISSET 루프를 돌려야 한다. 
Epoll의 경우 이벤트가 발생한 파일 디스크립터들만 구조체 배열을 통해 넘겨주므로 메모리 카피에 대한 비용이 줄어든다.
즉 커널이 관리하기에 리눅스 기반 시스템에서 밖에 못쓴다.
```    
- 네이티브 메소드를 사용할 경우 메모리는 네이티브 영역에 올라가기에 gc에서 회수 하지 못한다.
- 디버깅이 어렵다.
- 성능은 더 빠르나 안전하지 않을 수 있다. ex)netty, hazelcast => directBuffer 의 사용                                                


> 아이템 67. 최적화는 신중히하라.
- 빠른 프로그램보다는 좋은(안전한) 프로그램을 만들자.
- 성능 때문에 견고한 구조, 가독성을 희생하지 말자.
- 하지만 네트워크 프로토콜, 영구 저장용 데이터 포맷을 설계할 때 성능을 염두해야한다.

> 아이템 68. 일반적으로 통용되는 명명규칙을 사용해라.

- 일반적으로 통용되는 명명 규칙
    - ex) 자바 정적 팩토리 (from, of.. 등)
    - 참고: https://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html
- 자바 언어 명세(JSL, 6.1)에 따르면 오랫동안 따라온 규칙과 충돌한다면 그 규칙을 맹종해서는 안된다 상식이 이끄는대로 행동해라.
    
 