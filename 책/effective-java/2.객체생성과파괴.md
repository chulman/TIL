# 객체 생성과 파괴

> 아이템 1. 생성자 대신 정적 팩터리 메소드를 고려하라.

- 클래스는 public 생성자 대신 정적 팩토리 메소드를 제공할 수 있다.

### 장점
1. 명확한 이름을 가질 수 있다.
    + ex) Integer.parseInt(String value) vs new String(int i) => 정적 팩토리 메소드를 가진 쪽이 좀 더 의미를 잘 설명한다.
    + 입력 매개변수의 순서를 다르게 하는 것 보다는 명확한 이름을 가진 정적 팩토리 메소드로 의도를 표현해라.
    
2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
    + Immutable Class에 static한 변수를 설정해놓고 값들을 캐쉬해서, 기존 객체를 재활용 할 수있고, 성능을 높인다.
    + ex) Long.valueOf(String s)는 내부 static Class에 자주쓰이는 값들에 대해 Caching하고 있다. 
    
3. 반환 타입 하위 객체를 반환할 수 있는 능력이 있다.
    + 객체의 생성에 유연하다.
    + API 관점에서 반환 클래스의 구현부는 알 필요가 없다. 이는 정적 메소드의 큰 장점이다.
```text
예로 java.util.Collections가 그 예에 해당한다.
java.util.Collections는 45개에 달하는 인터페이스의 구현체의 인스턴스를 제공하지만 그 구현체들은 전부 non-public이다. 
즉 인터페이스 뒤에 숨어있고, 그 결과로 public 으로 제공해야 할 API를 줄였을 뿐 아니라 개념적인 무게 까지 줄일 수 있었다. 
개념적인 무게란 프로그래머가 어떤 인터페이스가 제공하는 API를 사용할 때 알아야 할 개념의 개수와 난이도를 말한다.
```
        
4. 입력 매개 변수에 따라 매번 다른 클래스를 반환할 수 있다.
    + 객체 생성의 의존성은 자연스럽게 줄어든다.
```java
public class Collections {
    private Collections() {
    }
public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K, ? extends V> m) {
        return new UnmodifiableMap<>(m);
    }
}
```    

5. 정적 패토리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.
    + 유연한 클래스 타입을 제공받을 수 있다.
    + 가장 이해하기 쉬운 예시로 DI가 있다. 이외에 Reflection이나 ServiceLoader 같은 경우도 있다는 점만 알아 두자.
    
### 단점
1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메소드만 제공하만 하위 클래스를 만들 수 없다.
    + 상속을 구현하면, 구현체의 불변성이 깨질 수 있기 때문에 장점이 될수 있다.

2. 정적팩토리 메소드는 프로그래머가 찾기 어렵다.
    + 객체 생성시 생성자를 통해 명확히 알 수 없으니, 정적 팩토리 메소드를 알고 있어야 사용할 수 있다.      


- https://johngrib.github.io/wiki/static-factory-method-pattern/ 
        
        
