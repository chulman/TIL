> 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라.

- 잘 설계된 컴포넌트는 외부로부터 내부 구현을 얼마나 잘 숨겼느냐에 있다.(캡슐화에 근간이 되는 개념)

-  캡슐화 함으로써 장점은 다음과 같다. (우리가 자주 사용하는 API들의 장점과 같다.)
    + 시스템 개발 속도를 높인다. (컴포넌트를 통해 병렬로 개발된다.)
    + 시스템 관리 비용을 낮춘다. (컴포넌트를 빨리 파악이 가능하고 디버깅이 가능하고 교체가능하다.)
    + 성능을 높여주진 않지만, 최적화는 가능하다.
    + 소프트웨어 재사용성을 높인다.
    + 큰 시스템을 제작하는 난이도를 낮춘다.

- 기본 원칙은 간단하다. 모든 클래스와 멤버의 접근성을 가능하면 최소화하여야 한다.

- 자바의 접근 제어는 (private, protected, public, package-private) 존재한다.
    + private: 멤버를 선언한 클래스에서만 접근할 수 있다.
    + package-private: 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.
    + protected: 기본적으로 package-private 범위에 포함되며, 하위클래스에도 접근이 가능하다.
    + public: 모든 곳에서 접근가능하다.(API화 될수 있다.)
    
- 한 클래스에서만 사용하는 package-private top level 클래스나 인터페이스는 클래스 안에 private static으로 중첩시켜 볼 수 있다.
```java
public class User {
...
}

class Name {
        ...
} 
```

```java
public class User {
...
    private static class Name {
        ...
    } 
}
```
- private와 package-private 멤버는 해당 클래스의 구현에 해당하므로 공개 api에 영향을 주지 않는다. 하지만 serializable을 구현한 클래스는 필드를 의도치 않게 공개할 수도 있다.(직렬화의 순서의 중요성에 따라)
- 멤버의 접근 수준을 protected로 바꾸는 순간 범위는 넓어질 수 있으므로, protected 범위는 최소한으로 하자.
- 리스코프 치환 원칙(LSP)에 따라 하위 클래스에서 상위 클래스의 범위보다 좁게 설정할 수 없을 수 있다.

- public 접근 제한의 주의사항
    + public 클래스의 인스턴스 필드는 되도록 public으로 설정하지 말아야 한다.(immutable을 보장할 수 없다.)
    + 덧붙여서 public 멤버필드는 스레드 안정성을 보장받지 못한다.
    + 필드가 상수라면 Public으로 사용해도 좋다.(public static final String name = "-");
    + 길이가 0이 아닌 배열은 모두 변경 가능하니 주의해야 한다.(상수화 하거나, 이 필드를 반환하는 메소드를 제공하지 말 것)
```java
private static final String[] test = {"a","b"};
// 어쩔 수 없이 필드를 반환해야 한다면 불변성을 보장하라
public static List<String> getTest() {
    // 새로운 list 객체로 생성하지 못하도록 방어
    return Collections.unmodifiableList(Arrays.asList(test));
}
```
- java 9에서는 모듈 시스템 기능이 제공되면서 두가지 암묵적 접근 수준이 추가되었다.
    + 모듈 제공: 패키지의 묶음을 모듈로써 export 할 지 선언할 수 있다.(export 하지 않았다면, public한 클래스더라도 외부에서 접근할 수 없다.)
        + https://www.oracle.com/corporate/features/understanding-java-9-modules.html
        + https://www.baeldung.com/java-9-modularity
    
    + 두가지 암묵적 수준은 public 혹은 protected 멤버와 연관이 있다. 이 접근 수준들은 모듈 내부로 한정되도록 변형된 것이다.
    
    + 주의 할점은 애플리케이션을 실행할 때 모듈이 존재하는 jar 파일을 클래스패스에 설정하면 모듈 공개 수준과 상관없이 모두 접근할 수 있다. 
```
// example
java -classpath/p:/prod/program/bootapp/module.jar -Dserver.port=8081 -jar app.jar
```


<br>

> 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메소드를 사용해라.

- 객체 지향 프로그래머들은 mutator 메소드를 통해 일반적으로 필드를 변경한다.

- package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출해도 괜찮을 수 있다.(어차피 클래스에 접근제한이 걸려있으니.)
```java
class Test {
    public String a;
    public String b;
}
```     
- 불변 필드를 public으로 노출하면 상태를 변경할 수 없다는 점에서 조금 보완할 수 있지만 과연 괜찮을까?
    + api로 명세화 해놨기 때문에 public 필드를 외부에서 사용하는 다른 모듈(클래스)등에서 전부 수정해야하는 상황이 발생할 수 있다.
    + 오직 불변성만을 제공할 뿐이다. 


> 아이템 17. 변경 가능성을 최소화하라.

- 불변(Immutable) 클래스란 간단히 말해 인스턴스의 내부 값을 수정할 수 없는 클래스다.

- 클래스를 불변성으로 만드는 5가지 규칙
    + 객체의 상태를 변경하는 메소드를 제공하지 않는다.
    + 클래스를 확장하지 못하도록 막는다.
    + 모든 필드를 Final로 선언한다.
    + 모든 필드를 Private로 선언한다.
    + 외부에서 내부 가변 컴포넌트에 접근할 수 없도록 한다.

- 불변 클래스는 단순하다. 생명주기 관점에서 생성되고 파괴되는 시점까지 값은 변하지 않는다.
- 불변 클래스는 당연하게도 쓰레드에 안전하다.
- 이에 따라 불변 객체는 자유롭게 내부에서든 외부에서든 공유가 가능하다.
- 불변객체를 참조해 구성 요소로 사용하면 이 점이 많다.(예를 들어 hashMap에서 해당 객체를 참조하는 hashCode는 변하지 않는다.)
- 실패 원자성을 제공한다. (상태가 변하지 않으니 잠깐이라도 불일치 상태에 빠질 일이 없다.)
- 단점은 값이 달라진다면 새로운 객체를 매번 생성해야 된다는 점이다.
    + StringBuilder를 예로 들 수 있는데 다단계 연산을 예측할 수 있는 Private static 클래스를 지정해서 개선할 수 있다.
    + 똑같은 값에 대해 미리 지정해 두어 개선할 수 있다.(Long 객체에서 자주쓰이는 값은 cash를 통해 해결한다.)

- 클래스를 상속하지 못하도록 하기 위해, final 키워드 대신 생성자의 접근을 막고 public 정적 팩토리 메소드를 제공하는 방법을 사용하면 된다.


<br>

> 아이템 18. 상속보다는 컴포지션을 사용하라.
- 상속은 코드를 재사용하는 강력한 수단이지만, 최선의 방법이 아니다.
- 메소드 호출과 달리 상속은 캡슐화를 깨뜨린다.
    + 상위 클래스의 구현에 따라 하위 클래스가 오작동 할 수 있기 때문이다.
    + hashSet 클래스의 addAll 메소드는 내부 add 메소드를 호출하므로, 하위 클래스의 재정의된 메소드에서 상위 메소드를 호출해도 오작동한다.

- 상속 대신 컴포지션을 활용하면 위와 같은 문제를 해결 할 수 있다.
    + 컴포지션은 기존 클래스(super)의 인스턴스를 참조하는 private 필드를 새로운 클래스에게 주입하는 방식 
    + 새로운 클래스에 포함된 기존 클래스의 인스턴스의 메소드에서는 기존 클래스에 포함된 함수들을 호출하여 결과를 반환해 주는데 이런 방법을 포워딩(Forwarding)이라 한다.
    + 이 방법을 통해 구현된 메서드는 Forwarding Method 라고 한다.
   
```java
public class ForwardingSet<E> implements Set<E> {

private final Set<E> s;
public ForwardingSet(Set<E> s) { this.s = s; }

@Override
public int size() { return s.size(); }

@Override
public boolean isEmpty() { return s.isEmpty(); }

 public boolean contains(Object o) { return s.contains(o); }

@Override
public Iterator<E> iterator() { return s.iterator(); }

@Override
public Object[] toArray() { return s.toArray(); }

@Override
public <T> T[] toArray(T[] a) { return s.toArray(a); }

@Override
public boolean add(E e) { return s.add(e); }

@Override
public boolean remove(Object o) { return s.remove(o); }

@Override
public boolean containsAll(Collection<?> c) { return s.containsAll(c); }

@Override
public boolean addAll(Collection<? extends E> c) { return s.addAll(c); }

@Override
public boolean retainAll(Collection<?> c) { return s.retainAll(c); }

@Override
public boolean removeAll(Collection<?> c) { return false; }

@Override
public void clear() { s.clear(); }

}
```

- Composition을 사용한 Fowarding클래스와 이를 감싸는 Wrapper클래스를 사용하여 상속보다 안전한 코드를 사용할 수 있다.
- wrapper 클래스는 단점이 거의 없지만, 콜백 프레임 워크와 어울리지 않는다.
- 상속은 반드시 하위 클래스가 상위 클래스의 진짜 하위 타입인 상항에서만 사용해야 한다.
    + 관계로 살펴보면, 상속은 is a 관계이고 컴포지션은 has a 관계
