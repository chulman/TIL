# 모든 객체의 공통 메소드
<br>

> 아이템 10. equals는 일반 규약을 지켜 재정의하라
- equals를 재정의 (overriding) 하기 쉬워보이지만 함정이 존재함.
- 다음과 같은 상황에서는 재정의하면 안된다.
    + 각 인스턴스가 본질적으로 고유한 경우 : Thread 가 예시가 됨. 값을 가지지 않고 쓰레드는 동작을 수행하는 클래스다.
    + 값의 동치를 검사할 필요가 없는 경우
    + 부모 클래스의 equals를 그대로 사용해도 무관한 경우(추상화된 부모 클래스의 상태 값)
    + 클래스가 Private or package-private 인 경우: 외부에서 호출할 필요가 없기 때문에
    
- equals를 재정의하는 경우는 일반적으로 다음과 같다.
    + 객체의 식별성(논리적 참조)가 아니라 객체의 값 비교(동치)
    
- Objects 클래스 명세에 적힌 규약(equals는 동치 관계를 구현하며 다음을 만족한다.)
    + 반사성: null 이 아닌 모든 참조 값 x 에 대해 x.equals(x)는 true - 자기 값은  항상 같다.
    + 대칭성: null 이 아닌 모든 참조 값 x,y 에 대해 x.equals(y)이면 y.equals(x)는 true
    + 추이성: null 이 아닌 모든 참조 값 x,y,z 에 대해 x.equals(y)이면 y.equals(z)는 true이면, z.equals(x)는 true 
     ```
        상위 클래스에 없는 상태를 하위 클래스에 추가할 때 주의해야 한다. 
        리스코프 치환 원칙에 따르면 sub type은 언제나 base type을 대체할 수 있어야 한다.
        LSP는 상속의 룰이다. OCP를 위반하지 않도록하는 원칙이다.
        그러므로 하위 클래스가 상위 클래스를 대체하더라도 동치는 ㄱ ㅏㅌ아야 한다.
  
     ```   
    
    + 일관성: null 이 아닌 x,y 의 동치 비교는 항상 True아니면 false를 갖는다.
    + null 아님 
    
- equals 작성 시 값 비교의 순서에 따라 성능이 좌우될 수 있음을 알아 두자
- 주의사항
    + equals 재정의 시 hashCode도 재정의 할 것
    + 너무 복잡하게 비교하여 해결하려 하지 말 것(상태 값 중 어떤 것에 대해 비교해야 하는 지 객체 지향적으로 고려하라.)
    + Object 외의 클래스를 매개변수로 받는 equals를 재정의하지 마라.(컴파일도 안된다.)
    
    
