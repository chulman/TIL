> 아이템 26. 로 타입은 사용하지 말라.

- 클래스나 인터페이스에 타입 파라미터가<?> 쓰이면 제네릭 클래스, 인터페이스라고 불린다.
- 제네릭 타입을 하나 정의하면, 로 타입도 함께 정의 한다.
    + 로 타입: 타입 매개변수를 전혀 사용하지 않음. ex) List, Collection ..
    + 로 타입은 타입 선언에서 마치 제네릭 타입 정보가 전부 지워진 것 처럼 동작하는데 제네릭 도입 전 모든 코드에 호환되기 위한 궁여 지책이었다.

- 로 타입을 쓰면 타입 safe에 대해 꼼꼼히 체크하지 않기 때문에 runtime 에러 가능성이 증가한다.
- 책에서 줄기차게 얘기하는 대로 오류는 최대한 컴파일에서 발견하는 것이 좋다.
- 런타임 시 오류를 찾기도 힘들고, 주석은 도움이 되지 않는다. 그렇기 때문에 제네릭은 type의 안정성을 확보한다.
- 로 타입은 애초에 호환성의 궁여지책이고, 로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃는다.
- List와 List<Object>는 전혀 다르다.
    + List에 비해 List<Object>는 제네릭을 사용해 Object 타입에 대해 모두 수용하게 된다. 즉 어떤 타입이든 add, get이 가능하다.
 
- 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 ?(비한정적 와일드 카드 타입-unbounded wildcard type)을 사용하자.
    + 위의 예와 마찬가지로 와일드 카드타입과의 차이점은 안정성이다. 와일드 카드 타입은 널을 제외한 어떤 원소도 넣을 수 없으며, 또한 꺼내는 원소의 타입을 알 수 없다.
    + 비한정적 와일드 카드 타입이 불편하다면, 한정적 와일드 카드 타입 <? extends T> 혹은 제네릭 메소드를 사용하자. (아이템 30, 31)

- 로 타입을 써야 하는 상황
    + 클래스 리터럴 : List.class (o), List<String>.class(x)
    + instanceof 연산: names instanceof List

- 캡처(capture) 에러 : ? 와일드카드를 사용하는데, 구체적인 타입이 필요할 때 / 컴파일러가 타입추론이 필요한데 하지 못할 경우
- 로 타입을 사용하면 런타임 예외가 발생할 가능성이 높다. 즉 로 타입은 안전하지 않은 호환성을 위한 궁여지책이므로 사용하지 말자.
 
 
 
 
 
 
 
 
