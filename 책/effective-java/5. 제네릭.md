> 아이템 26. 로 타입은 사용하지 말라.

- 클래스나 인터페이스에 타입 파라미터가<?> 쓰이면 제네릭 클래스, 인터페이스라고 불린다.
- 제네릭 타입을 하나 정의하면, 로 타입도 함께 정의 한다.
    + 로 타입: 타입 매개변수를 전혀 사용하지 않음. ex) List, Collection ..
    + 로 타입은 타입 선언에서 마치 제네릭 타입 정보가 전부 지워진 것 처럼 동작하는데 제네릭 도입 전 모든 코드에 호환되기 위한 궁여 지책이었다.

- 로 타입을 쓰면 타입 safe에 대해 꼼꼼히 체크하지 않기 때문에 runtime 에러 가능성이 증가한다.
- 책에서 줄기차게 얘기하는 대로 오류는 최대한 컴파일에서 발견하는 것이 좋다.
- 런타임 시 오류를 찾기도 힘들고, 주석은 도움이 되지 않는다. 그렇기 때문에 제네릭은 type의 안정성을 확보한다.
- 로 타입은 애초에 호환성의 궁여지책이고, 로 타입을 쓰면 제네릭이 안겨주는 안정성과 표현력을 모두 잃는다.
- List와 List<Object>는 전혀 다르다.
    + List에 비해 List<Object>는 제네릭을 사용해 Object 타입에 대해 모두 수용하게 된다. 즉 어떤 타입이든 add, get이 가능하다.
 
- 제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 ?(비한정적 와일드 카드 타입-unbounded wildcard type)을 사용하자.
    + 위의 예와 마찬가지로 와일드 카드타입과의 차이점은 안정성이다. 와일드 카드 타입은 널을 제외한 어떤 원소도 넣을 수 없으며, 또한 꺼내는 원소의 타입을 알 수 없다.
    + 비한정적 와일드 카드 타입이 불편하다면, 한정적 와일드 카드 타입 <? extends T> 혹은 제네릭 메소드를 사용하자. (아이템 30, 31)

- 로 타입을 써야 하는 상황
    + 클래스 리터럴 : List.class (o), List<String>.class(x)
    + instanceof 연산: names instanceof List

- 캡처(capture) 에러 : ? 와일드카드를 사용하는데, 구체적인 타입이 필요할 때 / 컴파일러가 타입추론이 필요한데 하지 못할 경우
- 로 타입을 사용하면 런타임 예외가 발생할 가능성이 높다. 즉 로 타입은 안전하지 않은 호환성을 위한 궁여지책이므로 사용하지 말자.
 
> 아이템 27. 비검사 경기롤 제거하라
- 제네릭을 사용하면 수많은 컴파일 경고를 보게 된다.(비검사 형변환 경고, 비검사 메소드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등)
- 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 위험요소가 있다.
- 경고를 제거할 수 없지만, 타입이 안전하다고 확신한다면 @Suppress Warnings("unchecked") 애노테이션을 통해 경고를 없앨 수 도 있다.(좁은 범위에 달자. 다른 경고를 숨길 수 있으므로.)
- 경고를 애너테이션을 통해 없애더라도, 추가 설명이 필요한 주석처리를 하자.
- 안전하다곡 검증된 비검사 경고를 그대로 두면, 진짜 문제를 알리는 새로운 경고가 나와도 눈치채지 못할 수 있다.

> 아이템 28. 배열보다는 리스트를 사용해라.
- 배열과 제네릭의 중요한 첫번 째 차이
    + 배열은 공변이다: 자신과 자식까지 타입을 허용한다.
    + 제네릭은 불공변이다: 무공변과 같은 듯. 자신의 타입만 허용한다.

```java
Object[] a = new Ling[3]; 
a[0] = "a"; // 런타임에 에러

List<Object> list = new ArrayList<String>();//컴파일부터 실패

```
- 배열과 제네릭의 중요한 두번 째 차이
    + 실체화 : 배열은 런타임 시 타입을 인지하고 확인하지만, 제네릭은 런타임 시 타입을 소거한다.

- 이상의 주요 차이로 인해 배열과 제네릭은 잘 어우러지지 못하며 List<E>[] 등은 허용되지 않는다.
    + 그 이유는 타입이 안전하지 못하기 떄문.
- 실체화 불가 타입 List<E>, List<String> 에 비해 실체화할 수 있는 타입은 List<?> 등 비한정적 와일드 카드 타입뿐이다.
- 제너릭 컬렉션에서는 자신의 원소 타입을 담은 배열을 반환하는게 보통은 불가능하다.
- 배열과 리스트를 섞어 쓰다가 컴파일 오류가 난다면, 배열을 리스트로 대체해보자.


> 아이템 29. 이왕이면 제네릭 타입으로 만들라.

- api 가 제공하는 제네릭 타입과 메소드는 사용하는 것은 쉬운일이다. 하지만만드는 일은 어렵다.

제네릭 만들기 예제

- before
```java
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        ensureCapacity();
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }
    
    public void push(Object element) {
        elements[size++] = element;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    
    private void ensureCapacity() {
        if(elements.length == size) {
            elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
}
```   
- 첫 단계는 클래스 선언에 타입 매개 변수를 추가한다. 그런 다음 사용될 필드를 바꿔보라. 그러면 아래 코드에서 문제가 발생한다.
```java 
    public Stack() {
            ensureCapacity();
            elements = new E[DEFAULT_INITIAL_CAPACITY];
        }
```

- 실체화 불가 타입(E,T.. 등)으로 배열을 만들수 없기 때문에 배열을 사용하는 코드를 제네릭으로 만들 때 문제가 발생한다.
- 해결방법 1: 비검사 형변환이 안전한지 확인하고 경고를 주석을 통해 숨긴다.
```java 
    @SupressWarning("unchecked")
    public Stack() {
            ensureCapacity();
            elements = (E[])new E[DEFAULT_INITIAL_CAPACITY];
        }
``` 
- 해결방법 2 : elements의 필드 타입을 E[] 에서 Object[]로 변경한다.
```java 
    public E pop() {
            if(size == 0)
                throw new EmptyStackException();
            
            @SupressWarning("unchecked") E result = (E)elemets[--size];
            
            elements[size] = null;
            return result;
        }
``` 
 
- 두 방법 모두 나름의 지지를 얻는다.
    + 첫번째 방법은 코드가 짧고 가독성이 좋다. 또한 형변환을 클래스 생성 시 한번만 해주면 된다. 하지만 타입이 object가 아닌 이상 [힙 오염](https://qastack.kr/software/155994/java-heap-pollution)이 발생할 수 있다.
    + 힙 오염이 걱정 되는 프로그래머는 두번 째 방식을 사용할 수 있다.
- 위 내용은 배열 대신 리스트를 사용하라(아이템 28)과 상충 될 수 있지만, 리스트를 사용하는게 항상 가능하지도 좋은 것도 아니다.
    + 자바가 리스트를 기본 타입(primitive type 해석됨)으로 제공하지 않기 때문에 언제든지 사용가능하지 않을 수 있다.
    + hashMap 같은 성능이 우선시 되기 곳에는 api인 ArrayList 보다 배열이 좋을 수 있다.
- 제네릭 타입은 참조 타입으로 생성이 가능하고, 기본 타입으로 사용할 수 없다.


> 아이템 30. 이왕이면 제네릭 메소드로 만들어라.

- 클래스와 마찬가지로 메소드도 제네릭으로 만들 수 있다. 매개변수화 타입을 받는 정적 유틸리티 메소드는 보통 제네릭이다. ex) Collections.BinarySearch, Sort..
- 타입 매개 변수 목록은 메소드의 제한자와 반환 타입 사이에 온다. (존재한다 정도.. public과 set<E>의 사이)
```java
public static <E> Set<E> union(Set<E> s1, Set<E> s2) {
    ...
}
```
- 타입 매개변수의 명명규칙은 제네릭 메서드나 제네릭 타입이나 똑같다.

- 제네릭 싱글턴 패턴
    + 제네릭은 런타임에 타입 정보가 소거 되므로 하나의 객체를 어떤 타입으로든 매개변수화 할 수 있다.
    + 하지만, 이렇게 하려면, 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리를 만들어야 한다. (제네릭 싱글턴 팩토리) ex) Collections.EmptySet

- 항등 함수
    + 항등함수는 특정 타입의 객체를 받으면 그 타입으로 반환하는 함수형 인터페이스(Function.identity)
    + 항등함수 객체는 상태가 없으니 요청할 때마다 새로운 객체가 생성되며 이는 낭비가 된다. 제네릭이 실체화된다면 타입별로 만들어야 겠지만 소거 방식 덕에 제네릭 싱글턴 하나면 충분하다.

```java
private static UnaryOperator<Object> IDENTITY_FN = (t) ->t; // Function.apply(t) { return t };
    
@SuppressWarnings("unchecked")
public static <T> UnaryOperator<T> identityFunction(){
    return (UnaryOperator<T>) IDENTITY_FN;
}

```
- IDENTITY_FN를 UnaryOperator<T>로 형변환 하면 비검사 형변환 경고가 발생한다. T가 어떤 타입이든 UnaryOperator<Object> 가 UnaryOperator<T> 아니라서..
- 그러나 항등 함수란 입력 값을 그대로 반환하는 함수이므로, 타입이 안전하고 @SuppressWarnings 으로 경고를 숨겨도 괜찮다.

- 재귀적 타입 한정
    + 드물자만 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정할 수 있다. 주로 Comparable 인터페이스와 함께 쓰인다.
    + 여기서 타입 매개변수 T는 Comparable<T>를 구현한 타입이 비교할 수 있는 원소의 타입을 정의한다. 실제로 거의 모든 타입은 자신과 같은 타입의 원소만 비교할 수 있다.
    + Comparable을 구현한 원소의 컬렉션을 입력받는 메소드 들은 주로 정렬, 검색, 최소값 최대값을 구하는데 사용된다.

```java
public static <E extends Comparable<T>> E max(Collection<E> c);
```
- 타입 한정인 <E extends Comarable<T>> 는 모든 타입 E는 자기 자신과 비교할 수 있다 정도로 해석하면 된다.
    + E에 대해 설정되는 타입은 Comparable을 구현한 구현체일 것이고, compareTo를 구현한 클래스에 대해서만 타입 매개 변수로 사용가능하다. 즉 자기자신과 비교될 수 있는 모든 타입 T 
- 재귀적 한정 타입은 훨씬 복잡해질 가능성이 있지만, 그런일은 잘 일어나지 않는다.

> 아이템31. 한정적 와일드 카드를 통해 와일드 카드의 효율성을 높여라.
