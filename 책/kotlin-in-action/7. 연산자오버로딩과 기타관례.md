# 연산자 오버로딩
- 어떤 클래스 안에 plus 라는 이름의 특별한 메소드를 정의하면 그 클래스의 인스턴스에 대해 + 연산자를 사용할 수 있다. 이런 식으로 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서는 관례(Convention)라고 부른다.
- 언어 기능을 타입에 의존하는 자바와 달리 코틀린은 (함수 이름을 통한) 관례에 의존한다. 이런 관례를 채택한 이유는 기존 자바 클래스를 코틀린 언어에 적용하기 위함이다.
-  기존  자바 클래스가 구현하는 인터페이스는  이미 고정돼 있고 코틀린 쪽에서 자바 클래스가 새로운ㄴ 인터페이스를 구현하게 만들 수는 없다.
- 반면 확장함수를 사용하면 기존 클래스에 새로운 메소드를 추가할 수 있다.

### 이항 산술 연산 오버로딩
- 코틀린 관례에서 사용하는 가장  단순한 예는 산순 연산자이다.
```kotlin
data class Point(val x: Int, val y: Int){
    operator fun plus(other: Point)
        = Point(x + other.x, y+other.y)
}
```
- 연산자를 오버로딩하는 함수 앞에는 꼭 operator 가 있어야 한다. p1+p2 는 a.plus(b) 함수 호출로 컴파일 된다. 아래 코드처럼 연산자를 확장함수로 정의할 수도 있다.
```kotlin
operator fun Point.plus(other: Point)
        = Point(x + other.x, y+other.y)
```

- 오버로딩 가능한 이항 산술 연산자
```kotlin
a*b -> times
a/b -> div
a%b -> mod (1.1 부터 rem)
a+b -> plus
a-b -> minus
```

- 직접 정의한 함수를 통해 구현하더라도 연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선 순위와 같다. (*,/,% > +,-)
- 연산자를 정의할 때 연산자 함수의 두 파라미터가 같은 타입일 필요는 없다.

```kotlin
operator fun Point.times(scale: Double) 
    = Point((x*scale).toInt(), (y * scale).toInt())
```
- 코틀린 연산자가 자동으로 교환법칙(a op b == b op a)을 지원하지는 않음에 유의하자.
   + 1.5 * p 로도 연산이 가능하게 하고 싶다면 operator fun Double.times(p: Point): Point 를 더 정의해야 한다.

- 결과 타입이 다른 피연산자 타입과 다른 연산자 정의도 할 수 있다.
```kotlin
operator fun Char.times(count: Int) = toString().repeat(count)
>>> println('a' * 3)
```

### 복합 대입 연산자 오버로딩
- 코틀린은 + 연산자 뿐 아니라 += plusAssign, -= minusAssign등 복합 대입 연산자도 지원한다.
- point += Point(3,4) 는 두 점의 좌표 성분을 각각 더한 성분으로 새로운 Point 객체를 반환한다.
```kotlin
val list = arrayListOf(1,2)
list += 3 // list를 변경 
val newList = list + listOf(4,5)  // 새로운 리스트를 반환

operator  fun <T> MutableCollection<T>.plusAssign(element:T) {
    this.add(element)
}
```

- 이론적으로는 코드에 있는 +=를 plus나 plusAssign 양쪽에 컴파일 할 수  있다.
    + 하지만 일반적으로 새로운 클래스를 일관성 있게 설계하는 것이 가장 좋다.
    + 동시에 정의하지 말자
```kotlin
a += b
a = a.plus(b)
a.plusAssign(b)
```     

- 코틀린 표준 라이브러리는 칼렉션에 대해 두가지 방법을  함께 제공한다. +,-는  항상 새로운 컬렉션을 반환하며 +=, -= 연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태를 변화시킨다.
    + 이런 연산자의 피연산자로는 개별워누소를 사용하거나  원소 타입이 일치하는 다른 컬렉션으 사용할 수 있다.
```kotlin
val list = arrayListOf(1,2)
list += 3   //  list += 는 list의 상태를 변경시킨다.
val newList  = list  + listOf(4,5)
```
