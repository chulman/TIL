# 연산자 오버로딩
- 어떤 클래스 안에 plus 라는 이름의 특별한 메소드를 정의하면 그 클래스의 인스턴스에 대해 + 연산자를 사용할 수 있다. 이런 식으로 어떤 언어 기능과 미리 정해진 이름의 함수를 연결해주는 기법을 코틀린에서는 관례(Convention)라고 부른다.
- 언어 기능을 타입에 의존하는 자바와 달리 코틀린은 (함수 이름을 통한) 관례에 의존한다. 이런 관례를 채택한 이유는 기존 자바 클래스를 코틀린 언어에 적용하기 위함이다.
-  기존  자바 클래스가 구현하는 인터페이스는  이미 고정돼 있고 코틀린 쪽에서 자바 클래스가 새로운ㄴ 인터페이스를 구현하게 만들 수는 없다.
- 반면 확장함수를 사용하면 기존 클래스에 새로운 메소드를 추가할 수 있다.

### 이항 산술 연산 오버로딩
- 코틀린 관례에서 사용하는 가장  단순한 예는 산순 연산자이다.
```kotlin
data class Point(val x: Int, val y: Int){
    operator fun plus(other: Point)
        = Point(x + other.x, y+other.y)
}
```
- 연산자를 오버로딩하는 함수 앞에는 꼭 operator 가 있어야 한다. p1+p2 는 a.plus(b) 함수 호출로 컴파일 된다. 아래 코드처럼 연산자를 확장함수로 정의할 수도 있다.
```kotlin
operator fun Point.plus(other: Point)
        = Point(x + other.x, y+other.y)
```

- 오버로딩 가능한 이항 산술 연산자
```kotlin
a*b -> times
a/b -> div
a%b -> mod (1.1 부터 rem)
a+b -> plus
a-b -> minus
```

- 직접 정의한 함수를 통해 구현하더라도 연산자 우선순위는 언제나 표준 숫자 타입에 대한 연산자 우선 순위와 같다. (*,/,% > +,-)
- 연산자를 정의할 때 연산자 함수의 두 파라미터가 같은 타입일 필요는 없다.

```kotlin
operator fun Point.times(scale: Double) 
    = Point((x*scale).toInt(), (y * scale).toInt())
```
- 코틀린 연산자가 자동으로 교환법칙(a op b == b op a)을 지원하지는 않음에 유의하자.
   + 1.5 * p 로도 연산이 가능하게 하고 싶다면 operator fun Double.times(p: Point): Point 를 더 정의해야 한다.

- 결과 타입이 다른 피연산자 타입과 다른 연산자 정의도 할 수 있다.
```kotlin
operator fun Char.times(count: Int) = toString().repeat(count)
>>> println('a' * 3)
```

### 복합 대입 연산자 오버로딩
- 코틀린은 + 연산자 뿐 아니라 += plusAssign, -= minusAssign등 복합 대입 연산자도 지원한다.
- point += Point(3,4) 는 두 점의 좌표 성분을 각각 더한 성분으로 새로운 Point 객체를 반환한다.
```kotlin
val list = arrayListOf(1,2)
list += 3 // list를 변경 
val newList = list + listOf(4,5)  // 새로운 리스트를 반환

operator  fun <T> MutableCollection<T>.plusAssign(element:T) {
    this.add(element)
}
```

- 이론적으로는 코드에 있는 +=를 plus나 plusAssign 양쪽에 컴파일 할 수  있다.
    + 하지만 일반적으로 새로운 클래스를 일관성 있게 설계하는 것이 가장 좋다.
    + 동시에 정의하지 말자
```kotlin
a += b
a = a.plus(b)
a.plusAssign(b)
```     

- 코틀린 표준 라이브러리는 칼렉션에 대해 두가지 방법을  함께 제공한다. +,-는  항상 새로운 컬렉션을 반환하며 +=, -= 연산자는 항상 변경 가능한 컬렉션에 작용해 메모리에 있는 객체 상태를 변화시킨다.
    + 이런 연산자의 피연산자로는 개별워누소를 사용하거나  원소 타입이 일치하는 다른 컬렉션으 사용할 수 있다.
```kotlin
val list = arrayListOf(1,2)
list += 3   //  list += 는 list의 상태를 변경시킨다.
val newList  = list  + listOf(4,5)
```
### 단항 연산자 오버로딩
- 단항연산자를 오버로딩하는 절차도 이항 연산자와 마찬가지다.
```kotlin
operator fun Point.unaryMinus() = Point(-x, -y)
```
- 단항 연산자를 오버로딩하기 위해 사용하는 함수는 인자를 취하지 않는다.
- 코틀린에서 오버로딩할 수 있는 모든 단항 연산자는 아래와 같다.
    + +a : unaryPlus
    + -a : unaryMinus
    + !a : not
    + ++a, a++ : inc
    + --a, a-- : dec

### 비교 연산자 오버로딩
- 코틀린에서는 == 비교 연산자를 직접 사용할 수 있어 비교 코드가 equals나 compareTo를 사용한 코드보다 더 직관적이다.

### 동등성 연산자 : equals
- 코틀린이 == 연산자를 equals ㅁ ㅔ소드 호출하며, != 연산자를 사용하는 식도 equals 호출로 컴파일된다.
- 식별자 비교 연산자는 자바 == 연산자와 같고, 피연산자가 같은객체인지 체크한다.
- equals 에는 override가 붙어 있다. 다른 연산자 오버로딩 관례와 달리  equals는 any에 정의된 메소드이므로 override가 필요하다.
- Any에는 Operator가 붙어있지만, override된 메소드 앞에는 붙이지 않아도 자동 적용된다.
```kotlin
(a == b) → (a?.equals(b) ?: (b == null))
// a가 널이라면 b도 널인 경우에만 결과가 true다.
//아래 equals 함수에는 override 가 붙어있다. 다른 연산자 오버로딩 관례와 달리 equals는 Any에 정의된 메소드이므로 override가 필요하다. 또한 Any에서 상속받은 equals가 확장 함수보다 우선순위가 높기 때문에 equals를 확장 함수로 정의할 수는 없다.
data class Point(val x: Int, val y: Int){
    override fun equals(other: Any?): Boolean {
        if(other === this) return true // this와 같은 객체인지 검사
        if(other !is Point) return false // 같은 타입인지 검사
        return other.x == x && other.y == y
    }
}
```
## 순서 연산자: compareTo
- 코틀린도 자바와 같은 Comparable 인터페이스를 지원한다. 코틀린은 Comparable 인터페이스 안에 있는 compareTo 메소드를 호출하는 관례를 제공한다. 따라서 <, >, ≥, ≤ 는 compareTo로 호출된다.
```kotlin
(a >= b) → (a.compareTo(b) >= 0)
compareTo 메소드 구현하기
class Person(val firstName: String, val lastName: String): Comparable<Person>{
    override fun compareTo(other: Person): Int {
      // 인자로 받은 함수를 차례로 호출하면서 값을 비교한다.
      return compareValuesBy(this, other, 
                    Person::firstName, Person::lastName)
    }
}
```

- compareValuesBy 는 첫 번째 비교 함수에 두 객체를 넘겨서 두 객체가 같지 않다는 결과(0이 아닌 값)가 나오면 그 결과 값을 즉시 반환하고, 아니면 계속 비교한다. 모든 함수가 0을 반환하면 0을 반환한다.
- compareValuesBy는 이런식으로 두 객체의 대소를 알려주는 0이 아닌 값이 처음 나올 때까지 인자로 받은 함수를 차례로 호출해 두 값을 비교하며, 모든 함수가 0을 반환하면 0을 반환한다.
- 각 비교 함수는 람다나 프로퍼티/메소드 참조  일 수 있다.
-  그렇지만 필드를 직접 비교하면, 코드는 복잡하지만 속도는  더 빨라 진다는  사실을 기억해야 한다.
    + 언제나 그렇듯 처음에는 성능을 신경쓰지 말고 이해하기 쉬운 간결한 코드를 작성하고, 추후 성능이 문제되면 개선하라
- Comparable 인터페이스를 구현하는 모든 자바 클래를 코틀린에서는 간결한 연산자 구문으로 비교할 수 있다.

```kotlin
println("abc" < "bac")
```
