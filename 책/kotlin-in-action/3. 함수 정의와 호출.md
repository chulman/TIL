> 3.1  코틀린에서 컬렉션 만들기
```kotlin
val set = hashSetOf(1, 7, 53)
val list = arrayListOf(1,7, 53)
// to 는 특별한 키워드나 함수강 아닌 일반함수이다.(중위함수)
val map  =  hashMapOf(1 to "one", 2  to "two")
``` 
- 코틀린에서 list, set, map은 자바 util 클래스를 그대로 가져다 쓴다.
- 코틀린의 3대 특징 간결성, 상호작용성, 신뢰성 중 자바와의 상호작용성과 관련 깊다.

> 3.2  함수를 호출하여 쉽게 만들기
```kotlin
fun <T> joinToString(
    collection: Collection<T>,
    separator: String,
    prefix:String,
    postfix:String
)  : string {
    ...
}

joinToString(list, ":" , "(", ")")
// 코틀린에서는 함수 호출 시 일부 또는 전부의 이름을 명시할 수 있다. 혼동을  줄 수 있는 인자가 섞여 있다면 반드시 명시해주자.
joinToString(list, separator = ":" , prefix = "(", postfix = ")")
```

### 디폴트 파라미터
- 자바에서는 일부 클래스에서 오버로딩한 메소드가 너무 많아진다는 문제가있다.
- 코틀린에서 디폴트 파라미터를 사용하여 불필요한 오버로드를 상당 수 피할 수 있다.

```kotlin
fun <T> joinToString(
    collection: Collection<T>,
    separator: String = ",",
    prefix:String = "",
    postfix:String =  ""
)  : string {
    ...
}

joinToString(list, ":" , "(", ")")
joinToString(list, ":" , "(")
joinToString(list, ":")
joinToString(list)
joinToString(list)
```

### 정적인 유틸리티 클래스 없애기
- 자바에서 유틸리티 클래스는 대개 아래처럼 만들어진다.
```java
public class JoinKt {
    public static String joinString(...);
}
```

- 코틀린에서는 함수를 소스파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다.
- 그런 함수들은 여전히 그파일의 맨앞에 정의된 패키지의 멤버함수이므로 다른 패키지에서 그 함수를 사용하고 싶을 때는 그 함수가 정의된 패키지를 임포트해야 한다.
- 하지만 임포트 시 유틸 클래스의 이름이 추가로 들어갈 필요는 없다.
- 아래파일의 소스코드를 jvm이 컴파일 할 때 새로운 클래스를 정의해주며, 컴파일한 결과 위와 동일하다. 
```kotlin
// joinKt.kt 파일
package strings
fun joinToString(...):String {...}
```

- 파일에 대응하는 클래스의 이름을 변경하고 싶으면 @jvmName 어노테이션을 추가하면 된다.
```kotlin
@file:JvmName("StringFunctions")

package strings
fun joinToString(...):String {...}

// java
StringFunctions.joinToString(...)
```

### 최상위 프로퍼티
- 함수와 마찬가지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다. (일어날 수 있는 상황은 흔하지 않다.)

```kotlin
// 이런 프로퍼티는 정적 변수에 저장된다.
var opCount = 0
// 상수로 만들 수 있는데, const 키워드는 자바의 public static final..과 같이 동작한다.
const val NEWLINE  = "\n"

fun performOperation() {
    opCount++
}
```


> 3.3 메소드를 다른 클래스에 추가: 확장함수오 확장 프로퍼티
