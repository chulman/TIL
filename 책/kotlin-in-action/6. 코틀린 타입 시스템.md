# 코틀린 타입 시스템
- 코틀린에서 가장 중요한 부분인 타입 시스템은 코드의 가독성을 향상시킨다.
- 그런 특성으로는 널이 될수 있는 타입과 읽기 전용  컬렉션이 있다.

> 6.1 널 가능성
- 코틀린을 비롯한 최신 언어에서 null에 대한 체크를 컴파일 시점으로 옮긴다.
- 널이  될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의  가능성을 줄일 수 있다.

### 널이 될수 있는 타입
- 자바와 달리 아래 코드는 컴파일 시점부터 null을 넘길 수 없다.
```kotlin
fun  strLen(s:String) = s.length

//null을 받을 수 있게 하려면 ? 연산자를 사용해야 한다.
// !!. 의미는 Non-null asserted 이다.
fun strLen(s:String?) = s!!.length
```

### 타입의 의미
>  타입은  어떤 값들이  가능한지와 그 타입에 대해 수행할 수 있는 연산의 종류를 결정한다.
- 자바에서 String 타입의 변수에는 String과 null이 들어갈 수 있다.
- 자바의 instanceof에서는 String의 null이 String 취급하지 않는다. 또한 연산자체도 완전히 다르다.
- 코틀린의 널이 될 수 있는 타입은 이런  문제를 해결한다. 널이 될 수 있는 타입과 널이 될 수 없는 타입은 어떤 연산이 가능할지 명확히 이해할 수 있고 실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다.
    + 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다. 모든 검사는 컴파일 시점에 체크 된다.

### 안전한 호출 연산자: ?.
- ?. 널 검사와 메소드 호출을 한번에 수행한다.
- 메소드 호출 뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다.
    + employee.manager?.name

### 엘비스 연산자: ?:
- 코틀린은 null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자를 제공한다.
```kotlin
val t:String = s ?: "default"
```        
- 코틀린에서는 throw나 return도 연산이라서 엘비스 연산자에 포함할 수 있다.
```kotlin
val address = person.company?.address ?: throw Exception("Illegal Exception")
```

### 안전한 캐스트:  as?

```kotlin
fun  equals(o:  Any?): Boolean {
    // as? 가 아니면 classCasException이 발생한다.
    // 타입이  맞지  않으면  Null을 리턴한다.
    return o as? Person?: return false
}
```

### 널 아님 단언: !!
- 널 아님 단언은  코틀린에서  널이 될 수 있는 타입의  값을 다룰 때 사용할 수 있는 도구 중 가장 단순하면서도 무딘 도구다.
- 느낌표를 이중으로 사용하면 어떤 값이든 널이 될 수 없는타입으로 바꿀 수 있으며, 널인 값이 적용하면 NPE가  발생한다.
```kotlin
fun ignoreNulls(s: String?) {
    val sNotNull: string = s!!
}
```

-  !!를 사용하면 예외가 발생했을 때 stacktrace에 어떤식의 예외가 발생했는지 자세히 담겨져  있지  않다.
    + 그러므로  다음과 같은 식은 지양하자.  ex) person.company!!.address!!.country!!

### let 함수
- let 함수를 사용하면 널이 될 수 있는 식을 더 쉽게 다룰 수 있다.
```kotlin
// null 을 넘길 수 없다.
fun sendEmailTo(email:String) {...}

// email이 null이면 아무일도 일어나지 않는다.
email?.let {sendEmailTo(it)}
```    

### 나중에 초기화할 프로퍼티의 사용 : lateInit
-  lateinit 프로퍼티는 항상 var 여야 한다.  valㄴ는 final filed로 컴파일되고 항상 생성자 안에서만 초기화해야한다.
```kotlin
class MyTest {
//    var myServer: MyService ?= null
    private lateinit var myService:MyService

    @Before
    fun setUp()  {
        myService = MyService()
    }
}
```
### 타입 파라미터의 널  가능성
```kotlin
fun <T> printHashCode(t: T) {   //null이 인자로 넘어오면 T의 타입을 any?로 추론된다.
    println(t?.hashCode())      // ?.를  통해 안전한 호출
}

// 타입 사항 지정: 널이 될수없음
fun <T: Any> printHashCode(t: T)...
```
### 플랫폼 타입
- 코틀린에서  널 관련 정보를 알 수 없는 타입을 말한다.
- 널이 될 수 있도록 혹은 될 수 없도록 처리해도 좋다. 책임은 우리에게 있다.
- 플랫폼 타입의 대표적인 예는 자바 타입이다.
```java
public class Person {
    // 네임은 널이 될 수도 안 될 수 도 있따.
    private final String name;
    public Person(String name) {
        this.name = name;
    }
}

// kotlin call - Illegal 예외  발생
Person(null).name.toUpperCase()
```
- 자바 api를 다룰 때는 조심해야 한다. 대부분 널 관련 처리를 다루지 않기 때문이다.
- 코틀린에는 플랫폼 타입이 없다.

### 상속
- 코틀린에서 자바 메소드를 오버라이드 할  때  그 메소드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할 지 널이 될 수 없는 타입으로  선언할지 결정해야 한다.
```kotlin
// 자바
interface StringProcessor {
    void process(String value);
}

class StringPrinter: StringProecssor {
    override fun process(val value: String)
}


class StringPrinter2: StringProecssor {
    override fun process(val value: String?)
}
```
- 코틀린에서 자바 메소드를 사용할 경우 널 가능성을 제대로 처리하는 일이 중요하다.
- 구현 메소드를 다른 코틀린 코드가 호출할 수 있으므로 코틀린컴파일러는 널이 될 수 없는 타입으로 선언한 모든 파라미터에 대해 널이 아님을 검사하는 단언문을 만들어준다.
    + 자바 코드가 그 메소드에게 널 값을 넘길 경우 이 단언문이  발동되 예외가 발생하게 된다.
