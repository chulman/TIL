# 코틀린 프로그래밍 개요

> 2.1 필드와 변수
```kotlin
fun main() {
    // val 키워드는 불변을 뜻함 (java final)
    val name: String = "frank"
    
   // 타입 생략
    /*
        코틀린은 필드를 초기화하는 값을 보고 변수의 타입을 추측한다.
        타입 추론 하는 데 있어서 타입을 생략도 될 때가 많다.
        하지만 타입 추론이 제대로 동작하지 않을 경우가 있는데 모호하거나 필드를 값으로 초기화하지 않은 경우
        일반적으로 타입을 지정하는 것이 좋다.        
    */      
    val name2 = "frank2"
    
    // 가변 필드
    /* 가능한 가변 필드가 아닌 val을 많이 사용해야 한다. 
        참조를 바꿀 수 없다면 일단 초기화 된 참조를 더럽힐 방법이 없기 떄문이다.
        var 사용은 최대한 피하는 편이 낫다. 위에 설명했듯이 프로그램 추론이 훨씬 쉽다.
    */
    var name3 = "franks3"
    name3 = "test"
    
    //지연 초기화
    // 참조 초기화를 늦추기 위해 var를 사용할 수 밖에 없지만, 일단 참조를 초기화해서 변경을 막고 싶을 때가 있다.
    // 지연 초기화를 하는 상황 - 초기화하는데 비용이 많이 들 떄
    
    // case 01 nullable type
    var lazyName: String? = null
    name = "test"
    
    // case 02 non-nullable type
    var lazyName2: String = "초기화안됨"
    lazyName = "test2"

    // case 03 by lazy 키워드
    val name: String by lazy(::getName)

    // case 04 가변참조를 지연 초기화를 사용해야 한다면 lateInit 키워드를 사용하자
    // DI 프레임워크 등의 외부에서 필드 초기화를 하는 경우를 제외하면 by lazy와 비교할 떄 장점이 없다.
    // DI 를 하더라도 불변 프로퍼티를 사용할 수 있으므로 언제나 생성자 기반의 의존 관계를 주입하려고 노력해야한다.
    lateinit var name: String
    ...
    name = getName()
   
}
```

> 2.2 클래스와 인터페이스

- 코틀린 클래스는 기본적으로 공개 클래스이다.
- 공개하지 않으려면, private, protected, internal modifier 를 사용해야 한다.
- 자바와 달리 protected는 클래스를 확장한 경우에만 사용할 수 있고, 다른 클래스에서는 접근할 수 없다.
- 코틀린 클래슨느 기본적으로 final 이다.
- 코틀린 클래스를 상속할 수 있게 하려면 open 변경자슬ㄹ 사용하면 된다.
- 생성자 정의가 클래스 이름 뒤에 온다
- 접근자가 필요없다.
- 자바와 달리 공개 클ㄹ래스 이름이 그 클래스가 담겨 있는 파일이름과 같을 필요가 없다 다르게 지정해도 된다. 그리고 더 많은 public 클래스가 한파일 내에 생성 가능하다. 
    + 하지만 권장되지는 않는거같다. 파일명과 클래스 이름이 같으면 찾기 쉬우니까

- 코드 간결하게 만들기    
```kotlin
// 생성자
class Person constructor(name: String) {
    val name: String = name
}

class Person constructor(val name: String) {
}

class Person(val name: String, val registered: Instant) {
}
```

- [기존 클래스 확장하기](../../kotlin/src/concision/extention.kt) 
- 인터페이스를 구현하거나 클래스를 확장하기
```kotlin
// 클래스에서 하나 이상의 인터페이스를 구현하거나 다른 클래스를 확장하고 싶다면 클래스 정의 뒤에 나열하면 된다.

 import java.io.Serializable

class Person(val name:String) :  Serializable, Comparable<Person> 
{
    constructor(): this("default") {}
}
// 상속하기 
open class Member(name: String) : Person(name) {
}

// 인스턴스 생성
fun main() {
    val person = Person("test")
    // getter와 setter 는 코틀린에서 컴파일러가 자동 생성한다.
    print(person.name)
}

// data 키워드는 hashCode 와 equals 를 자동 생성한다.
// 뿐만아니라, toString 함수와 copy 함수도 생성해준다.
data class DataClass(){}


// 프로퍼티가 N개 있는 데이터 클래스에는 component1부터 componentN까지 자동 정의된다.
// 이 함수들은 주로 사용하는 경우가 객체의 구조 분해이다.
// person.component1 ... 


// 코틀린 클래스는 정적 멤버가 없다. 그 대신 동반 객체라는 특별한 요소를 사용해 같은 효과를 얻을 수 있다.
data class Person(val name: String, val registered: Instant = Instant.now()) {
    companion object {
        fun create(xml: String): Person {
            // 코틀린에서 제공하는 TODO 함수
            TODO("write to data")
        }   
    }
}

fun main() {
    // 이런짓은 낭비다.
//    Person.Companion.create("")
    Person.create("")
}


// 싱글턴 사용하기: class 키워드 대신에 object 키워드만 사용하면된다.
// 이런 싱글턴 객체는 생성자가 있을 수 없다.
object MyWindowAdapter: WindowAdapter() {}


// 유틸 클래스 인스턴스화 방지하기
// 자바에서는 정적 메소드만 포함된 유틸 클래스를 만들어 사용하는 경우가 자주 있다,
// 코틀린에서 클래스 밖의 패키지 수준에서 함수를 만들면 유틸 클래스가 된다.

/*
package com.test.utils
fun create(xml: String): Person {}
*/
```

> 2.3 원시타입 없음
- 코틀린에서는 원시타입(primitive type)이 존재하지 않는다.
- 코틀린 내부에서 java primitive type을 사용하므로 계산하므로 더 빠르다.
- 수관련 특징
    + 64 비트 정수 타입(Long) 숫자 뒤에는 L을 붙이고, 기본 정밀도(single precision) 부동 소수점 타입 뒤에는 F를 붙인다.
    + Dobule의 숫자 타입은 2.0이나 .9처럼 소수점으로 정수와 구분한다.
    + 16진수 값은 맨앞의 0x를 붙인다.
        + 0x0DA15151
    + 2진수 앞에는 0b를 붙인다.
        + 0b01010101
- 그렇기 때문에 수나 bool 타입을 boxing, unboxing 할 필요가 없다.

> 2.4 컬렉션의 두 유형
- 코틀린 컬렉션은 자바 컬렉쎤을 사용하지만, 코틀린이 제공하는 기능이 추가 됐다.
- 코틀린에서 가장 중요한 점은 컬렉션에 불변과 가변이라는 두가지 유형이 있다는 점이다.

```kotlin
fun main() {
// 기본적으로 코틀린 컬렉션은 불변이다.(사실 진짜 불변이 아니다. 단지 원소를 변경하도록 허용하지 않는다.)
 val list = listOf("1", "2")
 val list2 = listOf("1", "2") + "3"
 val list3 = list + list2

// 가변 클래스
  val mutableList = mutableListOf("1","2","3")
    mutableList.add("4")


}
```
// plus 연산자는 plus라고 부르는 중위 연산자를 호출한다. [중위 연산 예](../../kotlin/src/concision/operation_overloading.kt)
// 연산자 오버로딩이 가능한 함수 plus, minus, times(*), div, rem(%)

> 2.5 패키지 
- 코틀린 패키지에서는 패키지가 저장된 디렉토리 구조와 패키지의 이름을 서로 일치시킬 필요가 없다.
- 마찬가지로 클래스를 자신의 이름과 같은 이름의 파일에 저장할 필요가 없다.
- 클래스가 들어 있는 패키지와 클래스가 정의된 파일이 들어있는 디렉토리의 구조를 꼭 일치시킬 필요도 없다.


- 패키지는 단지 식별자에 지나지 않는다. 코틀린에는 하위 패키지 라는 개념이 없다. 파일이름은 중요하지 않다.
- 하지만 자바와 같이 패키지와 디렉토리 구조를 일치시키는 관습을 채택하는 편이 좋은 두가지 이유가 있다.
    + 자바와 코틀린 파일을 혼합해서 사용해야 한다면 자바 파일을 패키지 이름과 일치하는 경로에 넣어야 한다.
    + 코틀린 소스 파일만 사용하는 경우라도 패키지와 소스 경로를 일치시키면 소스파일을 찾아내기가 더 쉽다.
